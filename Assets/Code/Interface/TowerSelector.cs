//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

namespace Caravan
{
	[RequireComponent (typeof (Button))]
	public class TowerSelector : MonoBehaviour
	{
		public GameObject range_display_reference;
		public GameElement draggable_reference;
		public float ReturnSpeed = 0.5f;
		public int SpawnRange;

		private GameObject DraggableElement;
		private GameObject DraggableElementRange;

		bool can_spawn_on_position = false;

		Vector3 original_position;

		GameController game_controller_ref;

		Image ui_image_ref; 
		RectTransform rect_transform_ref;

		RectTransform canvas_rectangle;
		Camera main_camera;

		Text cost_text_ref;

		void Awake(){

			game_controller_ref = GameController.GetInstance ();

			ui_image_ref = GetComponent<Image> ();
			rect_transform_ref = GetComponent<RectTransform> ();

			main_camera = FindObjectOfType<Camera> ();
			canvas_rectangle = FindObjectOfType<Canvas> ().GetComponent<RectTransform> ();

			cost_text_ref = GetComponentInChildren<Text> ();
		}

		void Start(){

			original_position = CanvasToWorld (transform.position);

			if (draggable_reference != null && cost_text_ref != null)
				cost_text_ref.text = draggable_reference.Gameplay_BuildCost.ToString();

			StartCoroutine (CoroutineCheckSpawnPosition ());

		}

		void FixedUpdate(){

			UpdateColor ();
		}

		public void StartDragging(){

			// create and position draggable element
			DraggableElement = new GameObject ();
			DraggableElement.transform.position = transform.position;

			// set draggable element's sprite
			SpriteRenderer draggable_sprite_renderer_ref = DraggableElement.AddComponent<SpriteRenderer> ();
			draggable_sprite_renderer_ref.sprite = draggable_reference.GetComponent<SpriteRenderer> ().sprite;


			float range_value = draggable_reference.GetRange ();

			if (range_value > 0) {

				// create and position range element
				DraggableElementRange = Instantiate (range_display_reference) as GameObject;
				DraggableElementRange.transform.parent = DraggableElement.transform;
				DraggableElementRange.transform.localPosition = Vector3.zero;

				// create and position range element
				//SpriteRenderer range_sprite_renderer_ref = DraggableElementRange.AddComponent<SpriteRenderer> ();
				//range_sprite_renderer_ref.sprite = draggable_reference.GetRangeDisplay().GetComponent<SpriteRenderer> ().sprite;
				
				DraggableElementRange.transform.localScale = new Vector3(range_value*2f,range_value*2f,1f);

			}

		}

		public void Drag(){

			if (DraggableElement != null) {

				DraggableElement.transform.position = CanvasToWorld(Input.mousePosition);
			}

		}
		
		public void StopDragging(){

			if (DraggableElement != null) {

				if ( can_spawn_on_position && HaveResources ()){

					BuildOnDraggablePosition();
				}
				else	

					StartCoroutine (CoroutineMove (DraggableElement.transform.position));
			}

		}

		void BuildOnDraggablePosition(){

			int building_cost = draggable_reference.Gameplay_BuildCost;
			Vector3 world_position = DraggableElement.transform.position;

			game_controller_ref.SpendResource (building_cost);
			
			Instantiate (draggable_reference.gameObject,world_position,Quaternion.identity);
			DestroyDragElement();

		}

		IEnumerator CoroutineMove(Vector2 current_position){

			float lerp = 0.0f;

			while (lerp < 1f) {

				int building_cost = draggable_reference.Gameplay_BuildCost;
				DraggableElement.transform.position = Vector3.Lerp(current_position,original_position,lerp);
				//DraggableElement.transform.position = CanvasToWorld(new_position);

				lerp += ReturnSpeed;

				yield return 0;

			}

			DestroyDragElement ();
		}

		void DestroyDragElement(){
			Destroy (DraggableElement);
			DraggableElement = null;
		}

		bool HaveResources(){

			int building_cost = draggable_reference.Gameplay_BuildCost;
			return (game_controller_ref.Resources >= building_cost);

		}

		private Vector3 CanvasToWorld(Vector2 Position){
			
			Vector3 position = Vector3.zero;
			
			RectTransformUtility.ScreenPointToWorldPointInRectangle (canvas_rectangle,
			                                                         Position,
			                                                         main_camera,
			                                                         out position);
			return position;
			
		}

		IEnumerator CoroutineCheckSpawnPosition(){

			while (true) {

				if (DraggableElement != null){

					//Vector3 world_position = CanvasToWorld(Input.mousePosition);
					Vector3 world_position = DraggableElement.transform.position;

					GameElement[] elements = FindObjectsOfType<GameElement> ();

					can_spawn_on_position = true;
					
					for (int i = 0; i < elements.Length; i++) {
						
						float distance = Vector3.Distance(elements[i].transform.position, world_position);
						
						if (distance < SpawnRange){
							can_spawn_on_position = false;
							break;
						}
							
					}

				}

				// wait for two fixed updates
				yield return new WaitForFixedUpdate();
				yield return new WaitForFixedUpdate();

			}

		}

		void UpdateColor(){

			if (can_spawn_on_position && HaveResources ()) {

				SetColor (new Color (1f, 1f, 1f, 0.8f));
				
			} else
				SetColor (new Color (1f, 0f, 0f, 0.3f));


		}

		// Set the color of all the elements
		void SetColor(Color c){

			ui_image_ref.color = c;

			if (DraggableElement != null) {
				
				DraggableElement.GetComponent<SpriteRenderer> ().color = c;
				
			}
			if (DraggableElementRange != null) {
				Color range_color = new Color (1f,1f,1f,c.a);

				DraggableElement.GetComponent<SpriteRenderer> ().color = range_color;
			}


		}



	}
}

